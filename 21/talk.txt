=== Goals

Why?
  1. Inspire people to run checkers
  2. Advertise myself
  3. Find people who are interested
  4. Find new projects

What?
  1. Show that it's easy to write, megatest and get bounties
  2. Present myself as an expert
  2. Advertise my checkers and GH in general
  3. Tell about hot topics
  4. Call for ideas

How?
  1. Give examples of checkers (the smaller the better)
  1. Show how many errors are out there
  2. Demonstrate understanding of the field
  2. Demonstrate hands on experience on what and how to test
  3. Demonstrate current status of RV in industry

=== Plan of talk

Overview:

* What's runtime checking (instrumentation)
* Much more widely used in industry than static tools
* Pros
  * no FPs
  * reprocases available
  * no scalability problems
* Cons
  * limited coverage (but fuzzing)

Taxonomy

* Types of checkers (by instrumentation type):
  * LD_PRELOAD (sortchecker)
  * asm (e.g. AFL or DirtyFrame)
  * compiler (e.g. Asan or DirtyPad)
  * source-level (Clang tooling)
  * runtime (e.g. DynamoRIO or Pin)
* Much easier for interpreted langs like Java/Python

Ontology

* Spec (...)
* Checker (check that trace adheres to spec via instrumentation)
* Corpus (tests, fuzzing, concolic)

Life of a checker

* Idea
  * the main innovation point
  * the rest if trivial nowadays
  * has to be easily checked (no package-specific specs in LTL or grammar-specific fuzzers although also popular)
  * gap between industry and academia (formals specs VS practical approaches like fuzzing)
  * often checking that APIs are called with correct params
    (e.g. free called with valid pointer)
  * mainly need more or less universal specification (library API (or OS syscall) requirements, language requirements e.g. UB or types)
* Developing instrumentation toolchain
* Wide-scale testing
* Triaging found issues (comparing against trunk, searching for dups in trackers, etc.)
* Filing patches and bugreports

Examples of checkers

* Most wide-known:
  * Virtual memory :)
  * Asserts in programs and libs (e.g. Glibc malloc invariant checks)
  * Valgrind
  * Sanitizers
  * AFL/libFuzzer

???

* Instead of testing that bad objects are not accessed, make sure that such accesses cause havoc
  * Fill undef memory/regs with garbage (MSVS does this with mallocked memory)
  * Unmap page after buffer to force segfault (ElectricFence)
  * Fill gaps in stack frame with random values (DirtyFrame)
  * Fill struct pads with random values (DirtyPad)
  * Intro random delays in Pthread-based programs

Testing

* Main goal: avoid manual work at all costs (slow => tiresome, demotivating)
* Cover as much packages as possible automagically

Dummy approach

* Run all apps in /bin and /usr/bin without params, with `--help`, `--version`

Debian

* https://en.wikipedia.org/wiki/Debian_build_toolchain
* Sadly only builds (not tests)

debian_pkg_test

* Hacking to the rescue!
* How to run tests w/o build system support

Hacking the build

* How to introduce different types of instrumentation:
  * LD_PRELOAD (just add to /etc/ld.so.preload)
  * asm - override as
  * compiler - override cc/c++/gcc/g++ by Clang (usually)

System tests (not unit tests like make check)

* Phoronix and other benchmark suites
* System boot

Gotchas

* For LD_PRELOAD: do not apply to system files
* For asm/compile: provide options via env variable
* Find interesting package faster:
  * popularity rating
  * Deb package search

Interesting topics:

* Automatic specification mining
  * "Mutation-driven Generation of Unit Tests and Oracles" https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.472.7671&rep=rep1&type=pdf
* Automatic test generation by on-the-fly mutation aka fuzzing (AFL/libFuzzer at wide-scale)
  * "Growing A Test Corpus with Bonsai Fuzzing" https://arxiv.org/pdf/2103.04388.pdf
  * "Whole testsuite generation" https://www.evosuite.org/wp-content/papercite-data/pdf/tse12_evosuite.pdf
  * alternative (more realistic?) industry solutions:
    * inspire project owners to write fuzzing for their projects (https://github.com/google/oss-fuzz)
    * bug bounties (https://portswigger.net/daily-swig/google-launches-fuzzilli-grant-program-to-boost-js-engine-fuzzing-research)
* Concolic OSS projects

Links:

* RV con: https://runtime-verification.github.io/ (Springer: https://link.springer.com/conference/rv)
* More practical:
  * DEFCON (https://www.defcon.org/images/defcon-15/)
  * Blackhat

===

Checker ideas:
  * malloc(0)/calloc(0)
  * free(0)
  * memcpy(0)
